% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/query.R
\name{wba_query}
\alias{wba_query}
\title{Query apps (Web API)}
\usage{
wba_query(
  start = NULL,
  count = NULL,
  sort = NULL,
  released_only = FALSE,
  coming_soon_only = FALSE,
  only_free_items = FALSE,
  exclude_free_items = FALSE,
  type_filters = NULL,
  tags = NULL,
  tags_exclude = NULL,
  content_descriptors = NULL,
  content_descriptors_exclude = NULL,
  regional_top_n = NULL,
  global_top_n = NULL,
  regional_longterm_top_n = NULL,
  global_longterm_top_n = NULL,
  sale_tagid = NULL,
  hub_type = NULL,
  hub_category = NULL,
  hub_tagid = NULL,
  discount_filter = NULL,
  optin_name = NULL,
  optin_tagid = NULL,
  prune_tagid = NULL,
  optin_only = FALSE,
  context = store_context(),
  data_request = store_data_request("basic_info"),
  paginate = FALSE,
  max_pages = Inf
)
}
\arguments{
\item{start}{Result page at which to start. The page count starts at 0.
If the page count exceeds the maximum pages, the output returns a
\code{count} attribute of 0.}

\item{count}{Number of results per page up to a maximum of 1,000. Defaults
to 10.}

\item{sort}{Number that seems to control the order of the apps when queried.
It is unknown what the number refers to.}

\item{released_only}{Whether to return only released applications.}

\item{coming_soon_only}{Whether to return only applications that are
being released in the future.}

\item{only_free_items}{Whether to return only applications without a
price tag.}

\item{exclude_free_items}{Whether to return only applications with a
price tag.}

\item{type_filters}{Specifies the types of applications to include in the
output. Can be one or several of \code{apps}, \code{packages}, \code{bundles},
\code{games}, \code{demos}, \code{mods}, \code{dlc}, \code{software},
\code{video}, \code{hardware}, \code{series}, and \code{music}.}

\item{tags}{A vector of tagIDs. Only games matching these tags will be
returned. Tags are categories or genres given to a game by the user
community. For an overview of existing tagIDs, see
\code{\link{wba_tags}}.}

\item{tags_exclude}{A vector of tagIDs. Only games \emph{not} matching
these tags will be returned. Tags are categories or genres given to a game
by the user community. For an overview of existing tagIDs, see
\code{\link{wba_tags}}.}

\item{content_descriptors}{A vector of content descriptor IDs. Only games
matching these tags will be returned. Content descriptors are descriptions
of the publisher on the explicitness of a game, e.g. strong language or gore.
For an overview of existing content descriptors, see
\code{\link{content_descriptors}}.}

\item{content_descriptors_exclude}{A vector of content descriptor IDs. Only
games \emph{not} matching these tags will be returned. Content descriptors
are descriptions of the publisher on the explicitness of a game, e.g. strong
language or gore.
For an overview of existing content descriptors, see
\code{\link{content_descriptors}}.}

\item{regional_top_n, regional_longterm_top_n}{Specifies the long-term or
short-term number of top games within the country specified by
\code{country_code}.}

\item{global_top_n, global_longterm_top_n}{Specifies the long-term or
short-term number of global top games.}

\item{sale_tagid}{Unknown. Probably the ID of a sale to query.}

\item{hub_type, hub_category, hub_tagid, discount_filter}{Unknown. Possibly
used to filter by content hub aka genre.}

\item{optin_name, optin_tagid, prune_tagid, optin_only}{Unknown. Possibly
related to Beta opt-in.}

\item{context}{Object of class
\code{\link[=store_context]{StoreBrowseContext}} that specifies the
geographic context from which to access the store. Defaults to a global
Steam realm (\code{steam_realm = 1}), English as the store language
(\code{language = "english"}) and the USA as the access country
(\code{country_code = "US"}).}

\item{data_request}{Object of class
\code{\link[=store_data_request]{StoreBrowseDataRequest}} that specifies
the additional information to be included. Defaults to no extra info.}

\item{iterate}{Whether to automatically iterate through pages. Depending
on the query, this can take a long time. The maximum number of requests
can be controlled using \code{options(steamr_max_reqs = ...)}.}
}
\value{
A dataframe containing information about the queried games.
The output contains three attributes \code{matches}, \code{start}, and
\code{count} reporting on the total number of matches, current page,
and number of matches returned. If \code{paginate = TRUE},
\code{start} is a vector of all paginated pages and \code{count} is the
sum of all paginated counts.

The number of rows is generally controlled using the \code{count} and
\code{paginate} arguments. However, the \code{*_top_n} arguments overwrite
the output count by their specified value.
}
\description{
Query apps using filters. Much of the argument documentation is still
unknown. Also, the \code{IStoreQueryService} interface defines two more
methods \code{SearchSuggestions} and
\code{GetItemByUserCombinedTagsPriority}, which might be really useful but
do not seem to work. If you have any hints, please let me know!
}
\section{\code{sort} parameter}{


The \code{sort} parameter seems to change the output but I have no idea how.
\code{wba_query} returns a unique set of appIDs for the following values:
\code{c(1, 2, 3, 8, 9, 10, 11, 12, 13, 20, 21, 22, 30, 31, 32, 34, 40, 41, 50)}

All other values passed to \code{sort} return the same set of appIDs as one
of the values specified above. The following script returns vector where each
index is a value passed to \code{sort} and each corresponding value is a
number between 1 to 50 that can be passed to \code{sort} to retrieve the same
sequence of appIDs.

\preformatted{idsets <- cvapply(1:1000, \(i) paste(wba_query(sort = i)$id, collapse = ""))
unique_sets <- which(!duplicated(idsets))
names(unique_sets) <- idsets[which(!duplicated(idsets))]
unname(unique_sets[idsets])
#   [1]  1  2  3  3  3  3  3  8  9 10 11 12 13  3  3  8  3  3  3 20
#  [21] 21 22  3  3  3  3  3  3  3 30 31 32  3 34  3  3  3  3  3 40
#  [41] 41 34  9  3  3 34  3  3  3 50  3  3 34  3  3  3  8  3  3  3
#  [61]  8  8  3  3  3  3  3  3  3  3 34 34  3 34  9  9  3  3  3  3
#  [81] 34 34  3  3  3  3  3  8  8  3  3  8  8  3  3  3  9  3  9  3
# [101]  3  3  3  3  3  3  9  3  3 34  3  8  3  3  3  3  3  3 34  9
# [121]  3  3  3  3  3  3  3  3  3  3  3 34  3 34  3 34  3  3  3  3
# [141]  3 34 34  3  3 34  3  3  3  3  3  3  3  3  9  3  3 34  3  3
# [161]  3  9  3  9  9  3  3  3  3  3  3  3  9  3  3  3  3  3  3  3
# [181]  3  3  3  9  3 34  9  9  8  3  9  3  3  3  3  8  3  8  3  3
# [201] 34  3  9  3  8  3  3  3  3  8  3  9  3  9  9  3  3 34  3  3
# [221] 34  9  3 34  3  3  3  3  3  3  3  3  3  3  3 34 34  3  3  3
# [241] 34  9  3  3  3  3  9  9  3  9  3  3 34  3  3  3  8  3 34  3
# [261]  3  9 34  3  3  3 34  3  3  9 34  3  3  3  3  9  3  3  3  3
# [281]  3  3  3  3  3  3  3  3  3  3  8  3  3  3  3 34  3  3  3  9
# [301]  3  3  3  3  3  3  3  3  3 34  9  3  3 34  3  3  3  8 34  3
# [321]  3  3 34  3  3  3 34  9  3  3  3  3  3  8  3  3  3  3  8  3
# [341]  9 34  3  3  3  3  3  3  9  3  3  9  3  3  3  3  8 34  3  3
# [361]  9  3  3  3  3  3  3  3 34  3  3  8 34  3  8  3  3  8  3 34
# [381]  9 34 34  3  3  3  3  3  3 34  3  9  3  3  3  9  3  3  3  3
# [401]  3  3  3  3  3 34  3  9  9  3  3  3  3  3  3  9  3  3 34  9
# [421]  3  3  3  3  3  3  9  9  9  3  3  3  3  3  3  3  3  3 34  3
# [441]  3  9  3  3  3  9  3  3  8 34  3  9  9  3  8  3  3  8 34  8
# [461] 34  3  3  3  3  3  3  3  3  3  9  3  9  3  8  3  3  8  3  3
# [481]  3  3  3  3  3  3  3  3  3  3  8  3  3  3  3  3  3  3  3  3
# [501]  3 34  3  3  3  3  3  9  3  3 34  3  3  3  3  3  3 34 34  9
# [521]  3  9 34  3  3  9  3  3 34  3  3 34  3  3  3  3  9  3  3  3
# [541]  3  3  3  3  3  9  9  9  3  3  3  3  3  3 34  3  3  3  3  3
# [561]  3  3 34  3  3  3  9 34  3  3  3 34  3  3  3  3  3  3 34  3
# [581]  3  3  3  3  3  8  3  3  3  3  3  3  3  3  3  3 34  3  3  8
# [601]  3  9  3  3  3  3  9  9  3  3  3  3 34  3  3  3  3  3  3  8
# [621]  9  3  8  3  3  9  3  3  3  3  3  3  3  9  3  3  3  3 34  8
# [641]  3  3  3  3  3 34  3  9  9  3  3 34  3  3  3  3  3  3  3  3
# [661] 34  3  3  9  3  3  3  9  3  3  9  3  3 34  3  3  3  3  3  3
# [681]  3  3  9  3 34 34  3 34 34  3  8  3  3 34  3  3  3  3  3  3
# [701]  3  9  3  3  3  3  3  3  3 34  3  3  3  3  9  3  3  3  3  3
# [721]  9  3 34  3  3  3  3  3  3  3  3  3  3  3  3  3  9 34  3  3
# [741]  9  8  8 34  9  3  3  3  3  3  3 34  3  3  3  8  3  3  3  3
# [761]  3  9 34  3  3  3  9  3  3  3  3  3  3  3  3  3 34  3  3  9
# [781] 34  3  3  3  3  3 34  3  3  3  3  3  3  3  3  3 34  3  3  3
# [801] 34  3  3  3  3  8  3 34  3  3  3 34  3  3  3  3  3  9  3  3
# [821]  3  9  3  3  3  3  3  8  3  3  8  3 34  3  3  8  3  3  9  3
# [841]  3  3  3  3 34  3  3  3  3  3  3  3  3  9  9  3  3  3  9  3
# [861]  3  3 34  9  3  3  3 34  3  3  3 34  3  9  3  3 34  8  3  3
# [881]  3  3  3 34  8  8  3  9  9  3  3  3  3  8  3  8  3  3  3  8
# [901]  3  8  3  3  9  3  9  3  8  3  3  3  8  9  3  3  3  3  3  3
# [921] 34  3  3  3  3  8 34  3  3  3  8  3  9  3  3  3  9  9  3 34
# [941]  3  3  9  3  3  3  3  3  3  3  3  9  3  3 34  3  3 34  3  9
# [961]  3  3  3  8  3  3  3  3  3  3  3 34  3 34  3  9  3  3  9  3
# [981]  3  3  3  3 34  8  9  9 34  3  8  9  3  3  9  8  3  3  3  3
}
}

\examples{
\dontrun{
# return the first 500 matches
wba_query(count = 500)

# return the first 2500 matches
options(steamr_max_reqs = 5)
wba_query(count = 500, paginate = TRUE)

# return page 5 of the query
wba_query(start = 6)

# sort by item type
wba_query(sort = 1)

# filter out mature content
cd <- content_descriptors()
cd <- cd[grepl("Mature Content", cd$description), ]$code
wba_query(content_descriptors_exclude = cd)

# filter by strategy games
tags <- wba_tags()
tagids <- tags[grepl("Strategy", tags$name), ]$tagid
wba_query(tags = tagids)

# out of all matches, return the 5 regional best-sellers
# note that "regional" refers to the store context provided
wba_query(regional_top_n = 5, context = store_context(country_code = "US"))
}
}
